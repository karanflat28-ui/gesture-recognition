<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Core: Warp & Flare Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            pointer-events: none;
            z-index: 10;
        }

        #mode-display { font-size: 2.5rem; margin: 0; letter-spacing: 5px; }
        #sub-status { font-size: 1rem; color: #ff4500; text-shadow: 0 0 5px #ff4500; }

        video.input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            border: 2px solid #00ffff;
            border-radius: 12px;
            transform: scaleX(-1);
            opacity: 0.6;
            z-index: 5;
        }

        #start-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: #00ffff;
            color: #000;
            border: none;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 50px;
            box-shadow: 0 0 30px #00ffff;
            transition: 0.3s;
            z-index: 100;
        }

        #start-btn:hover { background: #fff; box-shadow: 0 0 50px #fff; }
    </style>
</head>
<body>

    <button id="start-btn">ENGAGE NEBULA CORE</button>

    <div id="ui-layer">
        <h1 id="mode-display">CORE OFFLINE</h1>
        <p id="sub-status">SYSTEM READY - INITIALIZE TO START</p>
    </div>

    <video class="input_video" playsinline></video>

    <script>
        // --- AUDIO ENGINE ---
        let audioCtx, osc, gain;
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            osc = audioCtx.createOscillator();
            gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            osc.start();
        }

        // --- THREE.JS ENGINE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.autoClearColor = false; 
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const starCount = 6000;
        const geometry = new THREE.BufferGeometry();
        const pos = new Float32Array(starCount * 3);
        const col = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount; i++) {
            pos[i*3] = (Math.random() - 0.5) * 50;
            pos[i*3+1] = (Math.random() - 0.5) * 50;
            pos[i*3+2] = (Math.random() - 0.5) * 50;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
        const material = new THREE.PointsMaterial({ size: 0.07, vertexColors: true, transparent: true, opacity: 0.8 });
        const points = new THREE.Points(geometry, material);
        scene.add(points);
        camera.position.z = 25;

        // --- COLORS ---
        const colorCyan = new THREE.Color(0x00ffff);
        const colorOrange = new THREE.Color(0xff4500);
        const colorWhite = new THREE.Color(0xffffff);

        // --- GESTURE STATE ---
        let currentMode = "idle"; 
        let isStarted = false;

        function onResults(results) {
            if (!isStarted) return;
            
            const modeDisplay = document.getElementById('mode-display');
            const subStatus = document.getElementById('sub-status');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // Finger Detection Logic
                const indexUp = lm[8].y < lm[6].y;
                const middleUp = lm[12].y < lm[10].y;
                const ringUp = lm[16].y < lm[14].y;
                const pinkyUp = lm[20].y < lm[18].y;

                if (indexUp && !middleUp && !ringUp && !pinkyUp) {
                    currentMode = "warp";
                    modeDisplay.innerText = "WARP DRIVE";
                    subStatus.innerText = "ACCELERATING TO HYPERSPACE";
                    modeDisplay.style.color = "#ffffff";
                } else if (indexUp && !middleUp && !ringUp && pinkyUp) {
                    currentMode = "flare";
                    modeDisplay.innerText = "SOLAR FLARE";
                    subStatus.innerText = "CRITICAL CORE TEMPERATURE";
                    modeDisplay.style.color = "#ff4500";
                } else {
                    currentMode = "idle";
                    modeDisplay.innerText = "NEBULA IDLE";
                    subStatus.innerText = "STABLE ORBIT";
                    modeDisplay.style.color = "#00ffff";
                }
            } else {
                currentMode = "idle";
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if (!isStarted) return;

            const p = geometry.attributes.position.array;
            const c = geometry.attributes.color.array;

            // Trail Effect (Black Plane with varying opacity)
            const opacity = currentMode === "warp" ? 0.2 : 0.5;
            const fadeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: opacity });
            const fadeMesh = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), fadeMaterial);
            fadeMesh.position.z = camera.position.z - 1;
            scene.add(fadeMesh);

            // Audio Modulation
            if (audioCtx) {
                let freq = 110, vol = 0.02;
                if (currentMode === "warp") { freq = 500; vol = 0.1; osc.type = 'sine'; }
                else if (currentMode === "flare") { freq = 60; vol = 0.2; osc.type = 'sawtooth'; }
                else { osc.type = 'sine'; }
                osc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.1);
                gain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.1);
            }

            for (let i = 0; i < starCount; i++) {
                let ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;

                if (currentMode === "warp") {
                    p[iz] += 1.2; // Move toward camera fast
                    if (p[iz] > 25) p[iz] = -25; // Loop
                    c[ix] = 1; c[iy] = 1; c[iz] = 1; // Pure White
                } else if (currentMode === "flare") {
                    p[ix] += (Math.random() - 0.5) * 0.3; // Jitter
                    p[iy] += (Math.random() - 0.5) * 0.3;
                    c[ix] = colorOrange.r; c[iy] = colorOrange.g; c[iz] = colorOrange.b;
                } else {
                    // Drift
                    p[iz] += 0.03;
                    if (p[iz] > 25) p[iz] = -25;
                    c[ix] += (colorCyan.r - c[ix]) * 0.1;
                    c[iy] += (colorCyan.g - c[iy]) * 0.1;
                    c[iz] += (colorCyan.b - c[iz]) * 0.1;
                }
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
            scene.remove(fadeMesh);
        }

        // --- STARTUP ---
        const startBtn = document.getElementById('start-btn');
        startBtn.addEventListener('click', () => {
            isStarted = true;
            initAudio();
            startBtn.style.display = 'none';
            animate();
            
            const videoElement = document.querySelector('.input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            
            hands.onResults(onResults);

            const cameraHelper = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraHelper.start();
        });

        // Resize Handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>