<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nebula Core: Warp & Flare</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        video { position: absolute; bottom: 15px; right: 15px; width: 130px; border: 1px solid #ff4500; border-radius: 5px; transform: scaleX(-1); opacity: 0.4; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: #ff4500; pointer-events: none; text-transform: uppercase; letter-spacing: 2px; }
        #start-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 15px 30px; background: #ff4500; border: none; cursor: pointer; color: white; font-weight: bold; z-index: 100; }
    </style>
</head>
<body>
    <button id="start-btn">INITIALIZE CORE</button>
    <div id="ui"><h1 id="mode-display">NEBULA IDLE</h1><p id="sub-status">Awaiting Input...</p></div>
    <video class="input_video"></video>

    <script>
        // --- AUDIO ---
        let audioCtx, osc, gain;
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            osc = audioCtx.createOscillator();
            gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.connect(gain); gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            osc.start();
            document.getElementById('start-btn').style.display = 'none';
        }
        document.getElementById('start-btn').addEventListener('click', initAudio);

        // --- THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        // We use preserveDrawingBuffer: true to create trails manually
        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.autoClearColor = false; // Essential for Warp Trails
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const starCount = 5000;
        const geometry = new THREE.BufferGeometry();
        const pos = new Float32Array(starCount * 3);
        const col = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount; i++) {
            pos[i*3] = (Math.random()-0.5)*40;
            pos[i*3+1] = (Math.random()-0.5)*40;
            pos[i*3+2] = (Math.random()-0.5)*40;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));
        const mat = new THREE.PointsMaterial({ size: 0.08, vertexColors: true, transparent: true, opacity: 0.8 });
        const points = new THREE.Points(geometry, mat);
        scene.add(points);
        camera.position.z = 20;

        // --- GESTURE LOGIC ---
        let currentMode = "idle"; // "idle", "warp", "flare"
        const cyan = new THREE.Color(0x00ffff), orange = new THREE.Color(0xff4500), red = new THREE.Color(0xff0000);

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const indexUp = lm[8].y < lm[6].y, middleUp = lm[12].y < lm[10].y, 
                      ringUp = lm[16].y < lm[14].y, pinkyUp = lm[20].y < lm[18].y;

                if (indexUp && !middleUp && !ringUp && !pinkyUp) currentMode = "warp";
                else if (indexUp && !middleUp && !ringUp && pinkyUp) currentMode = "flare";
                else currentMode = "idle";
                
                document.getElementById('mode-display').innerText = currentMode === "idle" ? "NEBULA IDLE" : currentMode + " DRIVE";
            }
        }

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const p = geometry.attributes.position.array;
            const c = geometry.attributes.color.array;

            // Fade effect for trails
            const fadeOverlay = new THREE.Mesh(
                new THREE.PlaneGeometry(100, 100),
                new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: currentMode === "warp" ? 0.15 : 0.4 })
            );
            fadeOverlay.position.z = camera.position.z - 1;
            scene.add(fadeOverlay);

            if (audioCtx) {
                let f = 110, v = 0.02;
                if (currentMode === "warp") { f = 660; v = 0.15; osc.type = 'sine'; }
                else if (currentMode === "flare") { f = 55; v = 0.25; osc.type = 'sawtooth'; }
                osc.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.1);
                gain.gain.setTargetAtTime(v, audioCtx.currentTime, 0.1);
            }

            for (let i = 0; i < starCount; i++) {
                let ix = i*3, iy = i*3+1, iz = i*3+2;

                if (currentMode === "warp") {
                    p[iz] += 1.5; // Fly toward camera
                    if (p[iz] > 20) p[iz] = -40; // Loop back
                    c[ix] = 1; c[iy] = 1; c[iz] = 1; // Warp White
                } else if (currentMode === "flare") {
                    // Jitter / Heat effect
                    p[ix] += (Math.random()-0.5)*0.2;
                    p[iy] += (Math.random()-0.5)*0.2;
                    c[ix] = orange.r; c[iy] = orange.g; c[iz] = orange.b;
                    if (Math.random() > 0.9) { c[ix] = red.r; c[iy] = red.g; c[iz] = red.b; }
                } else {
                    // Idle Drift
                    p[iz] += 0.05;
                    if (p[iz] > 20) p[iz] = -40;
                    c[ix] += (cyan.r - c[ix]) * 0.1;
                    c[iy] += (cyan.g - c[iy]) * 0.1;
                    c[iz] += (cyan.b - c[iz]) * 0.1;
                }
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
            scene.remove(fadeOverlay); // Clean up overlay
        }
        animate();

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.8 });
        hands.onResults(onResults);
        new Camera(document.querySelector('.input_video'), {
            onFrame: async () => { await hands.send({image: document.querySelector('.input_video')}); },
            width: 640, height: 480
        }).start();
    </script>
</body>
</html>